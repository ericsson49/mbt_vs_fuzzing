# Model-Based Fuzzing Tutorial for SloppyVM

This tutorial explores model-based fuzzing (MBF) techniques for the SloppyVM virtual machine.

---

## Structure-Aware Testing (based on a model)

### The Limitations of Random Fuzzing

As noted in the [fuzzing tutorial](FUZZING_TUTORIAL.md), random byte sequences are effective at finding shallow violations like unknown opcodes and stack underflow conditions, but they struggle to reveal deeper semantic bugs. In a typical random fuzzer run against the [v2](sloppy_vm_impl_v2.py) implementation (where some shallow bugs are fixed):
- 99.9% of generated bytecodes are invalid (99,922 out of 100,000)
- Only 78 valid test cases are generated
- Zero bugs are discovered

We clearly see that random bytes rarely form valid instruction sequences. The VM has only 4 valid opcodes (0x01-0x04) out of 256 possible byte values, resulting in a very low probability of randomly generating something valid.

**Note:** These figures are exaggerated due to the really sloppy instruction encoding, but are not unrealistic.

### Structure-Aware Fuzzing

[Structure-aware fuzzing](https://en.wikipedia.org/wiki/Fuzzing#Aware_of_input_structure) addresses this by exploiting the **structure** of the system under test to generate syntactically valid inputs. Invalid instructions may also be generated. What's important is that we shape the probability distribution so that interesting cases appear more often.

### Model-based generation

Structure-aware test generation already resembles [model-based testing](https://en.wikipedia.org/wiki/Model-based_testing). We generate tests using a simple model:

```
Instruction = ADD() | MUL() | BYTE() | PUSH4(UInt32)
Program = Instruction+
```

Here's the [structure-aware](fuzzer.py#L32) generator, which can also produce invalid opcodes and truncated PUSH4 ops:

```python
def generate_structure_aware_bytecode(max_instructions: int = 10) -> bytes:
    instructions = []
    num_instructions = random.randint(1, max_instructions)

    for _ in range(num_instructions):
        opcode_roll = random.random()

        if opcode_roll < 0.45:  # PUSH4
            value = random.randint(0, 0xFFFFFFFF)
            # 5% chance of truncation for fuzzing error handling
            if random.random() < 0.05:
                value_bytes = value.to_bytes(4, 'big')
                truncate_to = random.randint(1, 3)
                instructions.append(bytes([OP_PUSH4]) + value_bytes[:truncate_to])
                break
            else:
                instructions.append(bytes([OP_PUSH4]) + value.to_bytes(4, 'big'))
        elif opcode_roll < 0.65:  # ADD
            instructions.append(bytes([OP_ADD]))
        # ... (MUL, BYTE, and invalid opcode cases follow)
```

This ensures coverage of both valid execution paths and error conditions.

### Results: Structure-Aware vs Random fuzzing

Comparing structure-aware and random fuzzing using the [v2](sloppy_vm_impl_v2.py) implementation with 100,000 tests:

| Generator | Valid Bytecodes | Invalid Bytecodes | Bugs Found |
|-----------|----------------|-------------------|------------|
| Random | 78 | 99,922 | 0 |
| Structured | 75,095 | 24,905 | 520 (~0.5%) |

Structure-aware fuzzing achieved ~1000x more valid test cases and thus helped to reveal several bugs:
- **Bug 3**: Missing 64-bit overflow masking for `ADD` and `MUL`
- **Bug 4**: Incorrect `BYTE` instruction indexing

It's worth noting again that the poor performance of random fuzzing here is partially due to inefficient bytecode encoding.

---

## Expression-based Model Fuzzing

Models are effective at guiding a fuzzer towards interesting test scenarios. Having identified and fixed stack underflow bugs, we now focus on exception-free bytecodes.

### The Expression Model

One straightforward approach is to generate random arithmetic expressions, consisting of `+`, `*`, `get_byte` ops and `uint32` constants. We can translate them to the SloppyVM instructions: proper translation will guarantee that the stack has enough values for each arithmetic op instruction.

The expression model defines an [abstract syntax tree (AST)](expression.py#L17) for arithmetic expressions:

```
Expr = Const(UInt32) | Add(Expr, Expr) | Mul(Expr, Expr) | Byte(Expr, Expr)
```

### Compiling Expressions

The model's [file](expression.py) includes a [compiler](expression.py#L58) that transforms expressions into SloppyVM instructions:

```python
def compile_expr_to_instructions(expr: Expr) -> List[Instruction]:
    match expr:
        case Const(value=val):
            return [PUSH4(val)]
        case Add(left=left, right=right):
            return (compile_expr_to_instructions(left) +
                    compile_expr_to_instructions(right) +
                    [ADD()])
        case Mul(left=left, right=right):
            return (compile_expr_to_instructions(left) +
                    compile_expr_to_instructions(right) +
                    [MUL()])
        case Byte(value=value, index=index):
            return (compile_expr_to_instructions(value) +
                    compile_expr_to_instructions(index) +
                    [BYTE()])
```

The translation guarantees that resulting instructions are semantically valid in the sense that each arithmetic operation will have enough arguments on stack (i.e. no stack underflow).

### Random Expression Generation

The model file also contains a [generator](expression.py#L96) of random expression trees with configurable `max_depth`. Additionally, we can shape the constant distribution by providing a suitable `const_generator`.

```python
def random_expr(max_depth: int, const_generator: Callable[[], int]) -> Expr:
    if max_depth <= 0:
        return Const(const_generator())

    choice = random.random()

    if choice < 0.4:
        return Const(const_generator())
    elif choice < 0.65:
        return Add(random_expr(max_depth - 1, const_generator),
                   random_expr(max_depth - 1, const_generator))
    elif choice < 0.9:
        return Mul(random_expr(max_depth - 1, const_generator),
                   random_expr(max_depth - 1, const_generator))
    else:
        return Byte(random_expr(max_depth - 1, const_generator),
                    random_expr(max_depth - 1, const_generator))
```

### Better Constant Sampling

By default, constants are sampled from `[0..UINT32_MAX]`. It makes it extremely unlikely to reveal [this bug](sloppy_vm_impl_v3.py#L72), since it manifests itself only if the top stack element is exactly `7`.

On the other hand, looking at the SloppyVM [spec](sloppy_vm_spec.py), we see that it makes sense to pay more attention to particular constant values. In the case of the `BYTE` [spec](sloppy_vm_spec.py#L209) we want to sample values from both `[0..7]` and `[8..UINT32_MAX]` ranges. With uniform sampling, we'll be almost always getting values from the latter one. We can solve it by passing a custom `const_generator`, e.g.:
```python
def custom_const_generator() -> int:
    if random.random() < 0.5:
        return random.randint(0, UINT32_MAX)
    else:
        return random.choice(range(0, 10))
```

**Note**: the [expression](fuzzer.py#L83) strategy uses a slightly different [approach](fuzzer.py#L102).

### Fuzzing Results

The resulting sampler reveals the last [bug](sloppy_vm_impl_v3.py#L72) instantly:
```bash
$ uv run fuzzer.py -i v3 -g expression -n 1000 -s 42
SloppyVM Fuzzer - Running 1000 tests
Testing: v3
Generator: expression
============================================================

Test 24: Bug found
  Bytecode: 010000000401ffffffff03010000000301000000070403010000000801000000020100000008020302
    [PUSH4(value=4), PUSH4(value=4294967295), MUL(), PUSH4(value=3), PUSH4(value=7), BYTE(), MUL(), PUSH4(value=8), PUSH4(value=2), PUSH4(value=8), ADD(), MUL(), ADD()]
  Expected: Success(stack=[51539607620])
  Actual:   Success(stack=[80])

...

============================================================
Fuzzer Summary
----------------------------------------
Total tests run:           1000
Invalid bytecodes:         0
Valid:                     1000
Bugs found:                16
Impl crashes:              0
Correct:                   984
Bug detection rate:     1.6%
```

---

## Implementation v4 (no known bugs)

After fixing this bug in [v4](sloppy_vm_impl_v4.py#L73) implementation, the fuzzer finds no further bugs even with 1,000,000 tests.
```bash
uv run fuzzer.py -i v4 -g expression -n 1000000 -s 42
SloppyVM Fuzzer - Running 1000000 tests
Testing: v4
Generator: expression
============================================================

============================================================
Fuzzer Summary
----------------------------------------
Total tests run:           1000000
Invalid bytecodes:         0
Valid:                     1000000
Bugs found:                0
Impl crashes:              0
Correct:                   1000000

No bugs detected!
```

---

## Conclusion

Model-based fuzzing is often straightforward to set up when the system under test is relatively simple. Real-world software, however, can be complicated and thus sampling interesting scenarios can become challenging. The model-based fuzzing remains valuable even in these cases: we can model an approximation of the SUT, or focus on critical aspects.

An alternative approach is to use finite models and enumerate all possible inputs. This gives us predictable, deterministic test generation with guaranteed coverage of the modeled functionality. We'll explore this enumeration-based approach in the next tutorial.

*Note*: Infinite models can typically be made finite by adding domain constraints, such as bounding input ranges or limiting depth. 