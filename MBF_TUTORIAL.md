# Model-Based Fuzzing Tutorial for SloppyVM

This tutorial explores model-based fuzzing (MBF) techniques for the SloppyVM virtual machine.

---

## Structure-Aware Testing (based on a model)

### The Limitations of Random Fuzzing

As noted in the [fuzzing tutorial](FUZZING_TUTORIAL.md), random byte sequences are effective at finding shallow violations like unknown opcodes and stack underflow conditions, but they struggle to reveal deeper semantic bugs. In a typical random fuzzer run against v2 (where some shallow bugs are fixed):
- 99.9% of generated bytecodes are invalid (99,922 out of 100,000)
- Only 78 valid test cases are generated
- Zero bugs are discovered

We clearly see that random bytes rarely form valid instruction sequences. The VM has only 4 valid opcodes (0x01-0x04) out of 256 possible byte values, resulting in a very low probability of randomly generating something valid.

**Note:** These figures are exaggerated due to the really sloppy instruction encoding, but are not unrealistic.

### Structure-Aware Fuzzing

[Structure-aware fuzzing](https://en.wikipedia.org/wiki/Fuzzing#Aware_of_input_structure) addresses this by exploiting the **structure** of the system under test to generate syntactically valid inputs. Invalid instructions may also be generated. What's important is that we shape the probability distribution so that interesting cases appear more often.

### Model-based generation

Structure-aware test generation already resembles [model-based testing](https://en.wikipedia.org/wiki/Model-based_testing). We generate tests using a simple model:

```
Instruction = ADD() | MUL() | BYTE() | PUSH4(UInt32)
Program = Instruction+
```

Here's the [structure-aware](fuzzer.py#L32) generator, which can also produce invalid opcodes and truncated PUSH4 ops:

```python
def generate_structure_aware_bytecode(max_instructions: int = 10) -> bytes:
    instructions = []
    num_instructions = random.randint(1, max_instructions)

    for _ in range(num_instructions):
        opcode_roll = random.random()

        if opcode_roll < 0.45:  # PUSH4
            value = random.randint(0, 0xFFFFFFFF)
            # 5% chance of truncation for fuzzing error handling
            if random.random() < 0.05:
                value_bytes = value.to_bytes(4, 'big')
                truncate_to = random.randint(1, 3)
                instructions.append(bytes([OP_PUSH4]) + value_bytes[:truncate_to])
                break
            else:
                instructions.append(bytes([OP_PUSH4]) + value.to_bytes(4, 'big'))
        elif opcode_roll < 0.65:  # ADD
            instructions.append(bytes([OP_ADD]))
        # ... MUL, BYTE, invalid opcode
```

This ensures coverage of both valid execution paths and error conditions.

### Results: Structure-Aware vs Random fuzzing

Comparing structure-aware and random fuzzing using [v2 implementation](sloppy_vm_impl_v2.py) with 100,000 tests:

| Generator | Valid Bytecodes | Invalid Bytecodes | Bugs Found |
|-----------|----------------|-------------------|------------|
| Random | 78 | 99,922 | 0 |
| Structured | 75,095 | 24,905 | 520 (~0.5%) |

Structure-aware fuzzing achieved ~1000x more valid test cases and thus helped to reveal several bugs:
- **Bug 1**: Wrong endianness for PUSH4
- **Bug 3**: Missing 64-bit overflow masking
- **Bug 4**: Incorrect BYTE instruction indexing

It's worth noting again that the poor performance of random fuzzing here is partially due to inefficient bytecode encoding.

---

## Expression-based Model Fuzzing

Models are effective at guiding a fuzzer towards interesting test scenarios. Having identified and fixed stack overflow bugs, we now focus on exception-free bytecodes.

### The Expression Model

One straightforward approach is to generate random arithmetic expressions, consisting of `+`, `*`, `get_byte` ops and `uint32` constants. We can translate them to the SloppyVM instructions: proper translation will guarantee that the stack has enough values for each arithmetic op instruction.

The expression model in `expression.py:17-47` defines an abstract syntax tree (AST) for arithmetic expressions:

```
Expr = Const(UInt32) | Add(Expr, Expr) | Mul(Expr, Expr) | Byte(Expr, Expr)
```

### Compilating Expressions

The model includes a compiler in `expression.py:58-83` that transforms expressions into SloppyVM instructions:

```python
def compile_expr_to_instructions(expr: Expr) -> List[Instruction]:
    match expr:
        case Const(value=val):
            return [PUSH4(val)]
        case Add(left=left, right=right):
            return (compile_expr_to_instructions(left) +
                    compile_expr_to_instructions(right) +
                    [ADD()])
        case Mul(left=left, right=right):
            return (compile_expr_to_instructions(left) +
                    compile_expr_to_instructions(right) +
                    [MUL()])
        case Byte(value=value, index=index):
            return (compile_expr_to_instructions(value) +
                    compile_expr_to_instructions(index) +
                    [BYTE()])
```

The translation guarantees that resulting instructions are semantically valid in the sense that each arithmetic operation will have enough arguments on stack (i.e. no stack underflow).

### Random Expression Generation

The model generates random expression trees with configurable max depth. Additionally, we can shape the constant distribution by providing a suitable `const_generator`.

```python
def random_expr(rng: Random, max_depth: int,
                const_generator: Callable[[Random], int]) -> Expr:
    if max_depth <= 0:
        return Const(const_generator(rng))

    choice = rng.random()

    if choice < 0.4:
        return Const(const_generator(rng))
    elif choice < 0.65:
        return Add(random_expr(rng, max_depth - 1, const_generator),
                   random_expr(rng, max_depth - 1, const_generator))
    elif choice < 0.9:
        return Mul(random_expr(rng, max_depth - 1, const_generator),
                   random_expr(rng, max_depth - 1, const_generator))
    else:
        return Byte(random_expr(rng, max_depth - 1, const_generator),
                    random_expr(rng, max_depth - 1, const_generator))
```

### Better Constant Sampling

By default, constants are sampled from `[0..UINT32_MAX]`. It makes it extremely unlikely to reveal the bug, since it requires the top stack element be exactly `7`. Looking at the spec, it makes sense to pay more attention to particular constant values. In the case of `BYTE` we want to sample values from both `[0..7]` and `[8..UINT32_MAX]` ranges. With uniform sampling, we'll be almost always getting values from the latter. We can solve it by passing a custom `const_generator`, e.g.:
```python
def custom_const_generator(rng: Random) -> int:
    if rng.random() < 0.5:
        return rng.randint(0, UINT32_MAX)
    else:
        return rng.choice(range(0, 10))
```

### Fuzzing Results

The resulting sampler reveals the last bug instantly:
```bash
$ uv run fuzzer.py -i v3 -g expression -n 1000 -s 42
SloppyVM Fuzzer - Running 1000 tests
Testing: v3
Generator: expression
============================================================

Test 24: Bug found
  Bytecode: 010000000401ffffffff03010000000301000000070403010000000801000000020100000008020302
    [PUSH4(value=4), PUSH4(value=4294967295), MUL(), PUSH4(value=3), PUSH4(value=7), BYTE(), MUL(), PUSH4(value=8), PUSH4(value=2), PUSH4(value=8), ADD(), MUL(), ADD()]
  Expected: Success(stack=[51539607620])
  Actual:   Success(stack=[80])

...

============================================================
Fuzzer Summary
----------------------------------------
Total tests run:           1000
Invalid bytecodes:         0
Valid:                     1000
Bugs found:                16
Impl crashes:              0
Correct:                   984
Bug detection rate:     1.6%
```

---

## Implementation v4 (no known bugs)

After fixing this bug in [v4](sloppy_vm_impl_v4.py#L73), the fuzzer finds no further bugs even with 1,000,000 tests.
```bash
uv run fuzzer.py -i v4 -g expression -n 1000000 -s 42
SloppyVM Fuzzer - Running 1000000 tests
Testing: v4
Generator: expression
============================================================

============================================================
Fuzzer Summary
----------------------------------------
Total tests run:           1000000
Invalid bytecodes:         0
Valid:                     1000000
Bugs found:                0
Impl crashes:              0
Correct:                   1000000

No bugs detected!
```

---

## Conclusion

If a system under test is relatively simple, model-based fuzzing is often straightforward to set up. However, it's not always the case, real-world software can be complicated, so sampling of important scenarios can become quite costly: space can be huge.
Model-based approach is still helpful here, as a model is often an approximation or depicts a particular aspect of SUT.

What's more interesting is that we don't have to limit ourselves with randomized sampling. If a model has a finite set of solutions and it's not too big, we can enumerate them all. Infinite models can typically be made finite, by adding additional constraints, such as domain bounds. We'll discuss the approach in the next tutorial.